"use strict";

(global => {
	// First define the global property µ. Leave that extensible, so that it can be extended by the users of the library
	// However, make the core utilities in the library frozen and unmodifiable to avoid unpleasant surprises
	const self = global;

	const assignConst = (target, name, value) => {
		const propertyDescription = {
			enumerable: true,
			configurable: false,
			writable: false,
			value: value,
		};

		return Object.defineProperty(target, name, propertyDescription);
	};

	const freezeAssign = (target, source) => {
		Object.entries(source).forEach(([name, value]) => {
			value = Object.freeze(value);

			assignConst(target, name, value);
		});

		return target;
	};

	const µ = freezeAssign(Object.create(null), {
		assignConst,
		freezeAssign,
	});

	// Selfishly hog the name "µ"
	assignConst(self, "µ", µ);

	if (!("micro" in self)) {
		self.micro = self.µ;
	}


	// A few useful integer constants
	(() => {
		// The limit of integers in two's complement representation
		µ.freezeAssign(µ, {
			minInt8: (-(2 ** 7)) | 0,
			maxInt8: ((2 ** 7) - 1) | 0,
			minUInt8: 0 >>> 0,
			maxUInt8: ((2 ** 8) - 1) >>> 0,

			minInt16: (-(2 ** 15)) | 0,
			maxInt16: ((2 ** 15) - 1) | 0,
			minUInt16: 0 >>> 0,
			maxUInt16: ((2 ** 16) - 1) >>> 0,

			minInt32: (-(2 ** 31)) | 0,
			maxInt32: ((2 ** 31) - 1) | 0,
			minUInt32: 0 >>> 0,
			maxUInt32: ((2 ** 32) - 1) >>> 0,
		});
	})();


	// A few small useful utilities
	(() => {
		const isFunction = func => (typeof func) === "function";

		// Similar to the first method shown on https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
		// Returns false if at least one parameter is not a finite number
		const floatEquals = (a, b) => {
			if (Number.isFinite(a) && Number.isFinite(b)) {
				const max = Math.max(Math.abs(a), Math.abs(b));
				return Math.abs(a - b) <= (max * Number.EPSILON);
			}

			return false;
		};

		µ.freezeAssign(µ, {
			isFunction,
			floatEquals,
		});
	})();


	// Random number generator using xoshiro128** algorithm by David Blackman and Sebastiano Vigna
	// http://xoshiro.di.unimi.it/xoshiro128starstar.c
	(() => {
		// State for the random generator. Int32 because most bitwise operators convert numbers to 32-bit signed int
		const rndState = new Int32Array(4);
		// Cryptographically secure random numbers guarantees good seed
		self.crypto.getRandomValues(rndState);

		const rotl = (x, k) => (x << k) | (x >>> (32 - k));

		const randInt = () => {
			// Math.imul ensures correct overflow behavior
			const x = Math.imul(rndState[0], 5);
			const result = Math.imul(rotl(x, 7), 9);
			const t = rndState[1] << 9;

			rndState[2] ^= rndState[0];
			rndState[3] ^= rndState[1];
			rndState[1] ^= rndState[2];
			rndState[0] ^= rndState[3];

			rndState[2] ^= t;

			rndState[3] = rotl(rndState[3], 11);

			return result;
		};

		const CAUTION_setSeed = array => {
			for (let i = 0; i < 4; ++i) {
				rndState[i] = array[i];
			}
		};

		const randBool = () => {
			// Convert most significant bit to boolean
			return randInt() < 0;
		};

		// Returns a generator which avoids bias by skipping over-represented candidates
		// The rejection is similar to the one in pcg32_boundedrand_r() in https://github.com/imneme/pcg-c-basic/blob/bc39cd76ac3d541e618606bcc6e1e5ba5e5e6aa3/pcg_basic.c
		// Also see "java.util.SplittableRandom.internalNextInt()" and "Random._randbelow_without_getrandbits()" in cpython/Lib/random.py
		const getRandomInt = (lowerBoundInclusive, upperBoundExclusive) => {
			const l = lowerBoundInclusive | 0;
			const u = upperBoundExclusive | 0;
			if ((lowerBoundInclusive !== l) || (upperBoundExclusive !== u) || // bounds must be 32-bit signed integers
				(l >= u)) { // lower bound must be larger than upper bound
				throw new RangeError("Invalid bounds");
			}

			// The maximum range is 0xffffffff, occurs with 2147483647 (2^31 - 1) as the upper bound and -2147483648 (- 2^31) as the lower bound
			// -> The entire range can be expressed as a 32-bit unsigned integer
			const d = (u - l) >>> 0; // Range as 32-bit unsigned int
			const m = (d - 1) >>> 0; // Bit mask

			// If the bounds are constants, a good (current/future?) VM should be able to "specialize" this function after a bit of inlining and
			// constant propagation
			if ((d & m) === 0) {
				// 1. case: the range is a power of two
				// -> use bit mask. always generates a number in one iteration
				return (randInt() & m) + l;
			} else {
				// 2. case: range is not a power of two
				// -> loop to reject over-represented values. expected number of iterations are between 1 and 2, depending on the range
				const max = µ.maxUInt32 + 1; // The amount of distinct integers that can be generated by randInt
				const threshold = (max % d) >>> 0; // numbers below this threshold are over-represented. threshold === 0 is handled in the 1. case

				let nextValue = randInt() >>> 0; // reinterpret as 32-bit unsigned int
				while (nextValue < threshold) {
					nextValue = randInt() >>> 0;
				}

				return (nextValue % d) + l;
			}
		};

		µ.freezeAssign(µ, {
			randInt,
			randBool,
			getRandomInt,
			CAUTION_setSeed,
		});
	})();


	// Minimal delay setTimeout using MessageChannel. Works in web workers and main window
	// Creates macro tasks, which won't block IO or the UI
	(() => {
		const channel = new MessageChannel();
		const receiver = channel.port1;
		const sender = channel.port2;

		const queuedFuncs = new Map();
		let nextTaskID = µ.minInt32;

		receiver.onmessage = event => {
			const taskID = event.data;
			const task = queuedFuncs.get(taskID);
			// Make sure below that the map can't contain explicitly set undefined values
			if (task !== undefined) {
				queuedFuncs.delete(taskID);
				task();
			}
		};

		// The id of the given task, which can be used to cancel that task
		const queueTask = func => {
			if (!µ.isFunction(func)) {
				throw new Error("Not a function");
			}

			const currentID = nextTaskID;
			++nextTaskID;
			queuedFuncs.set(currentID, func);
			sender.postMessage(currentID);

			return currentID;
		};

		// Returns true if the task was in the queue and is now removed, false if the id doesn't correspond to any tasks in the queue
		const cancelTask = taskID => {
			if (!Number.isSafeInteger(taskID)) {
				throw new Error("Invalid task id");
			}

			return queuedFuncs.delete(taskID);
		};

		µ.freezeAssign(µ, {
			queueTask,
			cancelTask,
		});
	})();


	// Accepts a int, float, boolean or string to create a data dependency, so that current and future javascript engines can't eliminate "dead code"
	// This is common in benchmarks, especially micro-benchmarks
	// Don't call an of the functions in a hot loop. While they shouldn't take long to execute, they'll still affect the performance
	// The caller has to make sure that the correct function is called depending on the type, otherwise it might not work reliably or at all
	(() => {
		const trashCan = Int32Array.of(µ.minInt32);
		const int16Bin = new Int16Array(trashCan.buffer);
		const writeOnly = new Float64Array(1);
		const readOnly = new Int32Array(writeOnly.buffer);

		// Retry every 24 days and 20 hours to see if crypto returns 65536 bytes of zero. In theory this should never happen
		self.setInterval(() => {
			const testArray = new Uint32Array(16384);
			self.crypto.getRandomValues(testArray);
			if (testArray.every(value => value === 0)) {
				console.error("This should never appear: %o", trashCan);
				console.dir(trashCan);
			}
		}, µ.maxInt32);

		const absorbInt = num => {
			trashCan[0] ^= num;
		};

		const absorbFloat = num => {
			writeOnly[0] = num;
			trashCan[0] ^= readOnly[0];
			trashCan[0] ^= readOnly[1];
		};

		const absorbString = str => {
			int16Bin[0] ^= str.charCodeAt(0);
			int16Bin[1] ^= str.charCodeAt(str.length - 1);
		};

		const absorbBool = bool => {
			trashCan[0] ^= (bool << 31);
		};

		µ.freezeAssign(µ, {
			absorbInt,
			absorbFloat,
			absorbString,
			absorbBool,
		});
	})();


	// This is a very rudimentary testing framework mostly used for benchmarking. It intentionally doesn't
	// have any kind of advanced features like assertions or async.
	// Can only accept one before and one after function
	(() => {
		const ticker = () => self.performance.now();

		const nop = x => x;

		class TestTemplate {
			constructor(testName = "Test") {
				this._name = testName
				this._before = nop;
				this._after = nop;
			}

			before(beforeTest = nop) {
				this._before = beforeTest;
				return this;
			}

			after(afterTest = nop) {
				this._after = afterTest;
				return this;
			}
		}

		class Test extends TestTemplate {
			constructor(testName = "Test") {
				super(testName);
			}

			test(testFunction) {
				this._test = testFunction;
				return this;
			}

			run(initialResource = {}) {
				if (this._test === undefined) {
					throw new Error("Incomplete test");
				}

				const testResource = this._before(initialResource);

				const startTime = ticker();
				const testResult = this._test(testResource);
				const testDuration = ticker() - startTime;

				const processedResult = this._after(testResult, testDuration);
				return {
					testResult: processedResult,
					testDuration,
					testName: this._name,
				};
			}
		};

		class TestSuite {
			constructor(testName = "TestSuite") {
				this._name = testName
				this._beforeAll = nop;
				this._testCases = [];
				this._afterAll = nop;
			}

			beforeAll(beforeTest = nop) {
				this._beforeAll = beforeTest;
				return this;
			}

			afterAll(afterTest = nop) {
				this._afterAll = afterTest;
				return this;
			}

			addTest(testCase) {
				this._testCases.push(testCase);
				return this;
			}

			run(initialResource = {}) {
				if (this._testCases.length === 0) {
					throw new Error("Incomplete test suite");
				}

				const testResource = this._beforeAll(initialResource);

				const startTime = ticker();
				const testResults = this._testCases.map(testCase => testCase.run(testResource));
				const testDuration = ticker() - startTime;

				const processedResults = this._afterAll(testResults, testDuration)
				return {
					testResult: processedResults,
					testDuration,
					testName: this._name,
				};
			}
		}

		µ.freezeAssign(µ, {
			TestTemplate,
			Test,
			TestSuite,
		});
	})();

})(self);
